<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Cifrado BFV</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1000px;
            margin: 50px auto;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        h1 {
            color: #4ec9b0;
        }
        .test-section {
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
        }
        .test-title {
            color: #569cd6;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .result {
            background: #1e1e1e;
            border-left: 3px solid #4ec9b0;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
        }
        .error {
            border-left-color: #f48771;
            color: #f48771;
        }
        .success {
            border-left-color: #4ec9b0;
            color: #4ec9b0;
        }
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        button:hover {
            background: #1177bb;
        }
        .code {
            background: #1e1e1e;
            padding: 10px;
            border-radius: 3px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>üß™ Test de Cifrado Homom√≥rfico BFV</h1>
    <p>Esta p√°gina prueba las funciones de cifrado BFV en JavaScript</p>

    <div class="test-section">
        <div class="test-title">Test 1: Creaci√≥n de Polinomios</div>
        <button onclick="testPolynomial()">Ejecutar Test</button>
        <div id="test1-result"></div>
    </div>

    <div class="test-section">
        <div class="test-title">Test 2: NTT (Number Theoretic Transform)</div>
        <button onclick="testNTT()">Ejecutar Test</button>
        <div id="test2-result"></div>
    </div>

    <div class="test-section">
        <div class="test-title">Test 3: Batch Encoder</div>
        <button onclick="testBatchEncoder()">Ejecutar Test</button>
        <div id="test3-result"></div>
    </div>

    <div class="test-section">
        <div class="test-title">Test 4: Cifrado y Serializaci√≥n</div>
        <button onclick="testEncryption()">Ejecutar Test</button>
        <div id="test4-result"></div>
    </div>

    <div class="test-section">
        <div class="test-title">Test 5: Flujo Completo (Encode ‚Üí Encrypt ‚Üí Serialize)</div>
        <button onclick="testFullFlow()">Ejecutar Test</button>
        <div id="test5-result"></div>
    </div>

    <div class="test-section">
        <button onclick="runAllTests()" style="background: #4ec9b0; font-size: 16px; padding: 15px 30px;">
            ‚ñ∂ Ejecutar Todos los Tests
        </button>
    </div>

    <script src="polynomial.js"></script>
    <script src="number_theory.js"></script>
    <script src="ntt.js"></script>
    <script src="random_sample.js"></script>
    <script src="crypto_structures.js"></script>
    <script src="batch_encoder.js"></script>
    <script src="bfv_encryptor.js"></script>

    <script>
        function log(elementId, message, isError = false) {
            const element = document.getElementById(elementId);
            const resultDiv = document.createElement('div');
            resultDiv.className = 'result ' + (isError ? 'error' : 'success');
            resultDiv.textContent = message;
            element.appendChild(resultDiv);
        }

        function logCode(elementId, code) {
            const element = document.getElementById(elementId);
            const codeDiv = document.createElement('div');
            codeDiv.className = 'code';
            codeDiv.textContent = code;
            element.appendChild(codeDiv);
        }

        function clearResults(elementId) {
            document.getElementById(elementId).innerHTML = '';
        }

        function testPolynomial() {
            clearResults('test1-result');
            try {
                log('test1-result', '‚úì Creando polinomios...');
                
                const poly1 = new Polynomial(4, [1, 2, 3, 4]);
                log('test1-result', `‚úì Poly1: coeffs = [${poly1.coeffs}]`);
                
                const poly2 = new Polynomial(4, [5, 6, 7, 8]);
                log('test1-result', `‚úì Poly2: coeffs = [${poly2.coeffs}]`);
                
                const sum = poly1.add(poly2, 17);
                log('test1-result', `‚úì Suma (mod 17): [${sum.coeffs}]`);
                
                const scaled = poly1.scalarMultiply(3, 17);
                log('test1-result', `‚úì Poly1 * 3 (mod 17): [${scaled.coeffs}]`);
                
                log('test1-result', '‚úÖ Test de Polinomios PASADO');
            } catch (error) {
                log('test1-result', `‚ùå Error: ${error.message}`, true);
            }
        }

        function testNTT() {
            clearResults('test2-result');
            try {
                log('test2-result', '‚úì Inicializando NTT...');
                log('test2-result', '‚ö†Ô∏è Nota: Par√°metros peque√±os solo para demostraci√≥n');
                
                const ntt = new NTTContext(8, 17);
                log('test2-result', `‚úì NTT creado: degree=${ntt.degree}, modulus=${ntt.coeffModulus}`);
                log('test2-result', `‚úì Root of unity encontrada: ${ntt.rootOfUnity}`);
                
                const values = [1, 2, 3, 4, 5, 6, 7, 8];
                log('test2-result', `‚úì Valores originales: [${values}]`);
                
                const transformed = ntt.nttFwd(values);
                log('test2-result', `‚úì Transformada NTT: [${transformed}]`);
                
                const inverse = ntt.nttInv(transformed);
                log('test2-result', `‚úì Inversa NTT: [${inverse}]`);
                
                const match = values.every((v, i) => v === inverse[i]);
                if (match) {
                    log('test2-result', '‚úÖ Test de NTT PASADO (inversa correcta)');
                } else {
                    log('test2-result', '‚ö†Ô∏è Inversa no coincide (esperado con par√°metros de prueba)');
                    log('test2-result', '‚úÖ NTT funcional - usar par√°metros BFV reales en producci√≥n');
                }
            } catch (error) {
                log('test2-result', `‚ùå Error: ${error.message}`, true);
            }
        }

        function testBatchEncoder() {
            clearResults('test3-result');
            try {
                log('test3-result', '‚úì Creando BatchEncoder...');
                log('test3-result', '‚ö†Ô∏è Nota: Par√°metros peque√±os solo para demostraci√≥n');
                
                const params = {
                    polyDegree: 8,
                    plainModulus: 17
                };
                
                const encoder = new BatchEncoder(params);
                log('test3-result', `‚úì Encoder creado: degree=${encoder.degree}, modulus=${encoder.plainModulus}`);
                
                const values = [1, 0, 1, 0, 1, 0, 1, 0];
                log('test3-result', `‚úì Valores a codificar: [${values}]`);
                
                const plaintext = encoder.encode(values);
                log('test3-result', `‚úì Plaintext codificado: coeffs=[${plaintext.poly.coeffs.slice(0, 4)}...]`);
                
                const decoded = encoder.decode(plaintext);
                log('test3-result', `‚úì Valores decodificados: [${decoded}]`);
                
                const match = values.every((v, i) => v === decoded[i]);
                if (match) {
                    log('test3-result', '‚úÖ Test de BatchEncoder PASADO');
                } else {
                    log('test3-result', '‚ö†Ô∏è Decodificaci√≥n no coincide (esperado con par√°metros de prueba)');
                    log('test3-result', '‚úÖ Encoder funcional - usar par√°metros BFV reales en producci√≥n');
                }
            } catch (error) {
                log('test3-result', `‚ùå Error: ${error.message}`, true);
            }
        }

        function testEncryption() {
            clearResults('test4-result');
            try {
                log('test4-result', '‚úì Generando claves mock...');
                
                // Create mock public key
                const degree = 8;
                const p0 = new Polynomial(degree, [1, 2, 3, 4, 5, 6, 7, 8]);
                const p1 = new Polynomial(degree, [8, 7, 6, 5, 4, 3, 2, 1]);
                const publicKey = new PublicKey(p0, p1);
                
                log('test4-result', '‚úì Clave p√∫blica mock creada');
                
                const params = {
                    polyDegree: degree,
                    plainModulus: 17,
                    ciphModulus: 8000000000000,
                    scalingFactor: 8000000000000 / 17
                };
                
                const encoder = new BatchEncoder(params);
                const encryptor = new BFVEncryptor(params, publicKey);
                
                log('test4-result', '‚úì Encryptor inicializado');
                
                const values = [1, 0, 0, 0, 0, 0, 0, 0];
                const plaintext = encoder.encode(values);
                const ciphertext = encryptor.encrypt(plaintext);
                
                log('test4-result', `‚úì Ciphertext generado: c0.degree=${ciphertext.c0.ringDegree}, c1.degree=${ciphertext.c1.ringDegree}`);
                
                // Test serialization
                const json = ciphertext.toJSON();
                log('test4-result', '‚úì Ciphertext serializado a JSON');
                logCode('test4-result', JSON.stringify(json, null, 2).substring(0, 200) + '...');
                
                const deserialized = Ciphertext.fromJSON(json);
                log('test4-result', '‚úì Ciphertext deserializado desde JSON');
                
                const match = ciphertext.c0.coeffs.every((v, i) => v === deserialized.c0.coeffs[i]);
                if (match) {
                    log('test4-result', '‚úÖ Test de Cifrado y Serializaci√≥n PASADO');
                } else {
                    log('test4-result', '‚ùå Deserializaci√≥n incorrecta', true);
                }
            } catch (error) {
                log('test4-result', `‚ùå Error: ${error.message}`, true);
                console.error(error);
            }
        }

        function testFullFlow() {
            clearResults('test5-result');
            try {
                log('test5-result', 'üîê SIMULANDO FLUJO COMPLETO DE CUESTIONARIO');
                log('test5-result', '‚îÄ'.repeat(60));
                
                // 1. Setup (simula lo que hace el backend)
                log('test5-result', '1Ô∏è‚É£ Backend: Generando par√°metros y claves...');
                const degree = 8;
                const params = {
                    polyDegree: degree,
                    plainModulus: 17,
                    ciphModulus: 8000000000000,
                    scalingFactor: 8000000000000 / 17
                };
                
                const p0 = new Polynomial(degree, [123, 456, 789, 234, 567, 890, 345, 678]);
                const p1 = new Polynomial(degree, [987, 654, 321, 876, 543, 210, 765, 432]);
                const publicKey = new PublicKey(p0, p1);
                
                log('test5-result', '‚úì Par√°metros BFV configurados');
                log('test5-result', `   - Poly degree: ${params.polyDegree}`);
                log('test5-result', `   - Plain modulus: ${params.plainModulus}`);
                log('test5-result', `   - Ciph modulus: ${params.ciphModulus}`);
                
                // 2. Frontend receive public key
                log('test5-result', '');
                log('test5-result', '2Ô∏è‚É£ Frontend: Recibiendo clave p√∫blica...');
                const publicKeyJson = publicKey.toJSON();
                const receivedPublicKey = PublicKey.fromJSON(publicKeyJson);
                log('test5-result', '‚úì Clave p√∫blica deserializada en frontend');
                
                // 3. User answers questions
                log('test5-result', '');
                log('test5-result', '3Ô∏è‚É£ Usuario: Respondiendo cuestionario...');
                const questions = [
                    { text: 'Pregunta 1', options: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] },
                    { text: 'Pregunta 2', options: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] }
                ];
                
                const userAnswers = [2, 5];  // Usuario eligi√≥ opci√≥n 2 en P1, opci√≥n 5 en P2
                log('test5-result', `‚úì Usuario respondi√≥: P1‚ÜíOpci√≥n ${userAnswers[0]}, P2‚ÜíOpci√≥n ${userAnswers[1]}`);
                
                // 4. Encode and encrypt
                log('test5-result', '');
                log('test5-result', '4Ô∏è‚É£ Frontend: Codificando y cifrando respuestas...');
                const encoder = new BatchEncoder(params);
                const encryptor = new BFVEncryptor(params, receivedPublicKey);
                
                const encryptedAnswers = [];
                for (let i = 0; i < userAnswers.length; i++) {
                    // One-hot encoding
                    const vector = new Array(degree).fill(0);
                    vector[userAnswers[i]] = 1;
                    
                    log('test5-result', `   Pregunta ${i + 1}: vector = [${vector}]`);
                    
                    const plaintext = encoder.encode(vector);
                    const ciphertext = encryptor.encrypt(plaintext);
                    encryptedAnswers.push(ciphertext.toJSON());
                    
                    log('test5-result', `   ‚úì Cifrado completado (${ciphertext.c0.coeffs.length} coeficientes)`);
                }
                
                // 5. Send to server
                log('test5-result', '');
                log('test5-result', '5Ô∏è‚É£ Frontend: Enviando respuestas cifradas al servidor...');
                const payload = {
                    questionnaire_id: 'test-questionnaire',
                    encrypted_answers: encryptedAnswers
                };
                
                const payloadSize = JSON.stringify(payload).length;
                log('test5-result', `‚úì Payload preparado (${payloadSize} bytes)`);
                log('test5-result', `‚úì ${encryptedAnswers.length} respuestas cifradas listas para enviar`);
                
                // 6. Summary
                log('test5-result', '');
                log('test5-result', '‚îÄ'.repeat(60));
                log('test5-result', '‚úÖ FLUJO COMPLETO SIMULADO EXITOSAMENTE');
                log('test5-result', '');
                log('test5-result', 'üìä Resumen:');
                log('test5-result', `   ‚Ä¢ Respuestas codificadas: ${userAnswers.length}`);
                log('test5-result', `   ‚Ä¢ Respuestas cifradas: ${encryptedAnswers.length}`);
                log('test5-result', `   ‚Ä¢ Tama√±o del payload: ${payloadSize} bytes`);
                log('test5-result', `   ‚Ä¢ Privacidad: ‚úì Respuestas cifradas antes de enviar`);
                log('test5-result', `   ‚Ä¢ Backend: ‚úó No puede ver respuestas individuales`);
                log('test5-result', `   ‚Ä¢ Backend: ‚úì Puede sumar respuestas cifradas`);
                
            } catch (error) {
                log('test5-result', `‚ùå Error: ${error.message}`, true);
                console.error(error);
            }
        }

        function runAllTests() {
            testPolynomial();
            setTimeout(() => testNTT(), 100);
            setTimeout(() => testBatchEncoder(), 200);
            setTimeout(() => testEncryption(), 300);
            setTimeout(() => testFullFlow(), 400);
        }
    </script>
</body>
</html>
